module alu(SW, LEDR, HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, KEY);
	input [9:0] SW;
	input [2:0] KEY;
	output [9:0] LEDR;
	output [6:0] HEX0;
	output [6:0] HEX1;
	output [6:0] HEX2;
	output [6:0] HEX3;
	output [6:0] HEX4;
	output [6:0] HEX5;
	wire [3:0] A_input;
	wire [3:0] B_input;
	assign A_input = SW[7:4];
	assign B_input = SW[3:0];

	alu_model a0(.A(A_input), .B(B_input), .key_select(KEY), .ALUout(LEDR));
	hex_display_model h0(.hex_input(B_input), .hex_output(HEX0));
	hex_display_model h1(.hex_input(4'b0000), .hex_output(HEX1));
	hex_display_model h2(.hex_input(A_input), .hex_output(HEX2));
	hex_display_model h3(.hex_input(4'b0000), .hex_output(HEX3));
	hex_display_model h4(.hex_input(LEDR[3:0]), .hex_output(HEX4));
	hex_display_model h5(.hex_input(LEDR[7:4]), .hex_output(HEX5));

endmodule


module alu_model(A,B,key_select,ALUout);

	input [3:0] A;
	input [3:0] B;
	output [7:0] ALUout;
	reg [7:0] ALUout;
	input [2:0] key_select;
	wire [7:0] reduction_oper;
	wire [7:0] case_0;
	wire [7:0] case_1;
	wire [7:0] case_2;
	reg [7:0] case_3;
	reg [7:0] case_4;
	wire [7:0] case_5;

//case_0
	ripple_carry_adder r0(.CIN(1'b0), .INPUT_1(A), .INPUT_2(B), .COUT(case_0[4]), .RESULT(case_0[3:0]));
assign case_0[7:5] = 3'b000;

//case_1
assign case_1 = A + B;

//case_2
assign case_2[7:4] = A ^ B;
assign case_2[3:0] = A | B;

//Combine A and B
assign reduction_oper[7:4] = A;
assign reduction_oper[3:0] = B;

//case_3 & case_4
always@(*)
	begin
		if(|reduction_oper)
			case_3 = 8'b10000001;
		else
			case_3 = 8'b00000000;

		if(&reduction_oper)
			case_4 = 8'b01111110;
		else
			case_4 = 8'b00000000;
	end

//case_5
assign case_5[7:4] = ~A;
assign case_5[3:0] = B;



always@(*)
	begin
		case(key_select)
			3'b000: ALUout = case_0;
			3'b001: ALUout = case_1;
			3'b010: ALUout = case_2;
			3'b011: ALUout = case_3;
			3'b100: ALUout = case_4;
			3'b101: ALUout = case_5;
			default: ALUout = 8'b00000000;
		endcase
	end

endmodule
