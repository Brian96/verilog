module alu(SW, LEDR, HEX0, HEX1, HEX2, HEX3, HEX4, HEX5, KEY);
input [9:0] SW;
input [2:0] KEY;
output [9:0] LEDR;
output [6:0] HEX0;
output [6:0] HEX1;
output [6:0] HEX2;
output [6:0] HEX3;
output [6:0] HEX4;
output [6:0] HEX5;
wire [3:0] A_input;
wire [3:0] B_input;
assign A_input = SW[7:4];
assign B_input = SW[3:0];

alu_model a0(.A(A_input), .B(B_input), .key_select(KEY), .ALUout(LEDR));
hex_display_model h0(.hex_input(B_input), .hex_output(HEX0));
hex_display_model h1(.hex_input(4'b0000), .hex_output(HEX1));
hex_display_model h2(.hex_input(A_input), .hex_output(HEX2));
hex_display_model h3(.hex_input(4'b0000), .hex_output(HEX3));
hex_display_model h4(.hex_input(LEDR[3:0]), .hex_output(HEX4));
hex_display_model h5(.hex_input(LEDR[7:4]), .hex_output(HEX5));

endmodule



module alu_model(A,B,key_select,ALUout);

input [3:0] A;
input [3:0] B;
output [7:0] ALUout;
reg [7:0] ALUout;
input [2:0] key_select;
wire [7:0] reduction_oper;
wire [7:0] case_0;
wire [7:0] case_1;
wire [7:0] case_2;
reg [7:0] case_3;
reg [7:0] case_4;
wire [7:0] case_5;

//case_0
ripple_carry_adder r0(.CIN(1'b0), .INPUT_1(A), .INPUT_2(B), .COUT(case_0[4]), .RESULT(case_0[3:0]));
assign case_0[7:5] = 3'b000;

//case_1
assign case_1 = A + B;

//case_2 
assign case_2[7:4] = A ^ B;
assign case_2[3:0] = A | B;

//Combine A and B 
assign reduction_oper[7:4] = A;
assign reduction_oper[3:0] = B;

//case_3 & case_4
always@(*)
	begin
		if(|reduction_oper)
			case_3 = 8'b10000001;
		else
			case_3 = 8'b00000000;
		
		if(&reduction_oper)
			case_4 = 8'b01111110;
		else
			case_4 = 8'b00000000;
	end
	
//case_5
assign case_5[7:4] = ~A;
assign case_5[3:0] = B;



always@(*)
	begin
		case(key_select)
			3'b000: ALUout = case_0;
			3'b001: ALUout = case_1;
			3'b010: ALUout = case_2;
			3'b011: ALUout = case_3;
			3'b100: ALUout = case_4;
			3'b101: ALUout = case_5;
			default: ALUout = 8'b00000000;
		endcase
	end
	
endmodule 

module ripple_carry_adder(CIN,INPUT_1,INPUT_2,COUT,RESULT);
	input [3:0] INPUT_1;
	input [3:0] INPUT_2;
	input CIN;
	output [3:0] RESULT;
	output COUT;
	wire [2:0] TEMP;
	
	full_adder_model f0(
	.a(INPUT_1[0]),
	.b(INPUT_2[0]),
	.cin(CIN),
	.s(RESULT[0]),
	.cout(TEMP[0])
	);

	full_adder_model f1(
	.a(INPUT_1[1]),
	.b(INPUT_2[1]),
	.cin(TEMP[0]),
	.s(RESULT[1]),
	.cout(TEMP[1])
	);
	
	full_adder_model f2(
	.a(INPUT_1[2]),
	.b(INPUT_2[2]),
	.cin(TEMP[1]),
	.s(RESULT[2]),
	.cout(TEMP[2])
	);
	
	full_adder_model f3(
	.a(INPUT_1[3]),
	.b(INPUT_2[3]),
	.cin(TEMP[2]),
	.s(RESULT[3]),
	.cout(COUT)
	);
	
endmodule



module full_adder_model(a,b,cin,s,cout);
	input a, b, cin;
	output s, cout;
	assign s = cin ^ (a ^ b);
	mux2to1 u0(b,cin,a^b,cout);
	
endmodule

module mux(LEDR, SW);
    input [9:0] SW;
    output [9:0] LEDR;

    mux2to1 u0(
        .x(SW[0]),
        .y(SW[1]),
        .s(SW[9]),
        .m(LEDR[0])
        );
endmodule

module mux2to1(x, y, s, m);
    input x; //select 0
    input y; //select 1
    input s; //select signal
    output m; //output
  
    //assign m = s & y | ~s & x;
    // OR
    assign m = s ? y : x;

endmodule
